<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinexis Backend - Pose Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        #startScreen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(180deg, #f5f7fa 0%, #e1e5ea 100%);
            position: relative;
            overflow: hidden;
        }

        /* Technical line pattern background */
        .tech-pattern {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        /* Grid nodes - connection points */
        .node-grid {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .node {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #D2A10C;
            border-radius: 50%;
            opacity: 0.3;
        }

        .node::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border: 1px solid #D2A10C;
            border-radius: 50%;
            top: -3px;
            left: -3px;
            opacity: 0;
            animation: nodePulse 3s ease-in-out infinite;
        }

        /* Node positions - creating a grid */
        .node:nth-child(1) { top: 15%; left: 20%; animation-delay: 0s; }
        .node:nth-child(2) { top: 15%; left: 50%; animation-delay: 0.5s; }
        .node:nth-child(3) { top: 15%; left: 80%; animation-delay: 1s; }
        .node:nth-child(4) { top: 35%; left: 10%; animation-delay: 0.3s; }
        .node:nth-child(5) { top: 35%; left: 35%; animation-delay: 0.8s; }
        .node:nth-child(6) { top: 35%; left: 65%; animation-delay: 1.3s; }
        .node:nth-child(7) { top: 35%; left: 90%; animation-delay: 1.8s; }
        .node:nth-child(8) { top: 55%; left: 25%; animation-delay: 0.6s; }
        .node:nth-child(9) { top: 55%; left: 50%; animation-delay: 1.1s; }
        .node:nth-child(10) { top: 55%; left: 75%; animation-delay: 1.6s; }
        .node:nth-child(11) { top: 75%; left: 15%; animation-delay: 0.9s; }
        .node:nth-child(12) { top: 75%; left: 40%; animation-delay: 1.4s; }
        .node:nth-child(13) { top: 75%; left: 60%; animation-delay: 1.9s; }
        .node:nth-child(14) { top: 75%; left: 85%; animation-delay: 2.4s; }
        .node:nth-child(15) { top: 90%; left: 30%; animation-delay: 1.2s; }
        .node:nth-child(16) { top: 90%; left: 70%; animation-delay: 1.7s; }

        @keyframes nodePulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0;
            }
            50% {
                transform: scale(2);
                opacity: 0.5;
            }
        }

        /* Connecting lines between nodes */
        .connection-lines {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .connection {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, #AA2513, transparent);
            transform-origin: left center;
            opacity: 0.2;
            animation: connectionDraw 4s ease-in-out infinite;
        }

        /* Diagonal and straight connections */
        .connection:nth-child(1) {
            width: 200px;
            top: 15%;
            left: 20%;
            transform: rotate(25deg);
            animation-delay: 0s;
        }
        .connection:nth-child(2) {
            width: 350px;
            top: 15%;
            left: 50%;
            transform: rotate(-15deg);
            animation-delay: 0.5s;
        }
        .connection:nth-child(3) {
            width: 250px;
            top: 35%;
            left: 10%;
            transform: rotate(45deg);
            animation-delay: 1s;
        }
        .connection:nth-child(4) {
            width: 300px;
            top: 35%;
            left: 35%;
            transform: rotate(-30deg);
            animation-delay: 1.5s;
        }
        .connection:nth-child(5) {
            width: 180px;
            top: 55%;
            left: 25%;
            transform: rotate(20deg);
            animation-delay: 2s;
        }
        .connection:nth-child(6) {
            width: 220px;
            top: 55%;
            left: 50%;
            transform: rotate(-45deg);
            animation-delay: 2.5s;
        }
        .connection:nth-child(7) {
            width: 280px;
            top: 75%;
            left: 15%;
            transform: rotate(35deg);
            animation-delay: 3s;
        }
        .connection:nth-child(8) {
            width: 320px;
            top: 75%;
            left: 40%;
            transform: rotate(-20deg);
            animation-delay: 3.5s;
        }

        @keyframes connectionDraw {
            0%, 100% {
                width: 0;
                opacity: 0;
            }
            50% {
                width: 100%;
                opacity: 0.3;
            }
        }

        /* Angle measurements */
        .angle-indicators {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .angle-arc {
            position: absolute;
            width: 60px;
            height: 60px;
        }

        .arc-path {
            stroke: #D2A10C;
            stroke-width: 1;
            fill: none;
            stroke-dasharray: 40;
            stroke-dashoffset: 40;
            opacity: 0.4;
            animation: drawAngle 3s ease-in-out infinite;
        }

        .angle-text {
            position: absolute;
            color: #AA2513;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            opacity: 0;
            animation: angleAppear 3s ease-in-out infinite;
        }

        /* Angle indicator positions */
        .angle-indicator:nth-child(1) { top: 30%; left: 25%; }
        .angle-indicator:nth-child(2) { top: 50%; right: 30%; }
        .angle-indicator:nth-child(3) { bottom: 25%; left: 40%; }
        .angle-indicator:nth-child(4) { top: 20%; right: 20%; }

        .angle-indicator:nth-child(1) .angle-text::after { content: "45°"; }
        .angle-indicator:nth-child(2) .angle-text::after { content: "90°"; }
        .angle-indicator:nth-child(3) .angle-text::after { content: "120°"; }
        .angle-indicator:nth-child(4) .angle-text::after { content: "60°"; }

        @keyframes drawAngle {
            0%, 100% {
                stroke-dashoffset: 40;
                opacity: 0;
            }
            50% {
                stroke-dashoffset: 0;
                opacity: 0.5;
            }
        }

        @keyframes angleAppear {
            0%, 100% {
                opacity: 0;
                transform: scale(0.8);
            }
            60%, 90% {
                opacity: 0.6;
                transform: scale(1);
            }
        }

        /* Grid lines */
        .grid-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.05;
        }

        .grid-line {
            position: absolute;
            background: #D2A10C;
        }

        .grid-line.horizontal {
            width: 100%;
            height: 1px;
            left: 0;
        }

        .grid-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .grid-line.horizontal:nth-child(1) { top: 10%; }
        .grid-line.horizontal:nth-child(2) { top: 20%; }
        .grid-line.horizontal:nth-child(3) { top: 30%; }
        .grid-line.horizontal:nth-child(4) { top: 40%; }
        .grid-line.horizontal:nth-child(5) { top: 50%; }
        .grid-line.horizontal:nth-child(6) { top: 60%; }
        .grid-line.horizontal:nth-child(7) { top: 70%; }
        .grid-line.horizontal:nth-child(8) { top: 80%; }
        .grid-line.horizontal:nth-child(9) { top: 90%; }

        .grid-line.vertical:nth-child(10) { left: 10%; }
        .grid-line.vertical:nth-child(11) { left: 20%; }
        .grid-line.vertical:nth-child(12) { left: 30%; }
        .grid-line.vertical:nth-child(13) { left: 40%; }
        .grid-line.vertical:nth-child(14) { left: 50%; }
        .grid-line.vertical:nth-child(15) { left: 60%; }
        .grid-line.vertical:nth-child(16) { left: 70%; }
        .grid-line.vertical:nth-child(17) { left: 80%; }
        .grid-line.vertical:nth-child(18) { left: 90%; }

        /* Calculation numbers floating */
        .calc-numbers {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .calc-num {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #AA2513;
            opacity: 0;
            animation: calcFade 5s ease-in-out infinite;
        }

        .calc-num:nth-child(1) { top: 25%; left: 15%; animation-delay: 0s; }
        .calc-num:nth-child(1)::after { content: "θ = 45.2°"; }

        .calc-num:nth-child(2) { top: 45%; left: 70%; animation-delay: 1s; }
        .calc-num:nth-child(2)::after { content: "∠ = 90.0°"; }

        .calc-num:nth-child(3) { top: 65%; left: 40%; animation-delay: 2s; }
        .calc-num:nth-child(3)::after { content: "ROM: 120°"; }

        .calc-num:nth-child(4) { top: 35%; right: 25%; animation-delay: 3s; }
        .calc-num:nth-child(4)::after { content: "Δ = 15.7°"; }

        .calc-num:nth-child(5) { bottom: 30%; left: 60%; animation-delay: 4s; }
        .calc-num:nth-child(5)::after { content: "α = 67.3°"; }

        @keyframes calcFade {
            0%, 100% {
                opacity: 0;
                transform: translateY(5px);
            }
            20%, 80% {
                opacity: 0.4;
                transform: translateY(0);
            }
        }

        /* Animations */
        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-30px);
            }
        }

        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes slideRight {
            0% {
                left: -150px;
                opacity: 0;
            }
            10% {
                opacity: 0.08;
            }
            90% {
                opacity: 0.08;
            }
            100% {
                left: 100%;
                opacity: 0;
            }
        }

        @keyframes slideLeft {
            0% {
                right: -150px;
                opacity: 0;
            }
            10% {
                opacity: 0.08;
            }
            90% {
                opacity: 0.08;
            }
            100% {
                right: 100%;
                opacity: 0;
            }
        }

        @keyframes heartbeat {
            0% {
                stroke-dashoffset: 300;
            }
            50% {
                stroke-dashoffset: 0;
            }
            100% {
                stroke-dashoffset: -300;
            }
        }

        @keyframes drawArc {
            0% {
                stroke-dashoffset: 150;
            }
            50% {
                stroke-dashoffset: 0;
            }
            100% {
                stroke-dashoffset: -150;
            }
        }

        @keyframes fadeInOut {
            0%, 100% {
                opacity: 0;
            }
            50% {
                opacity: 0.6;
            }
        }
        #startBtn {
            padding: 20px 60px;
            font-size: 24px;
            font-weight: 400;
            background: linear-gradient(90deg, #D2A10C 0%, #AA2513 50%, #D2A10C 100%);
            background-size: 200% 100%;
            animation: gradientShift 3s ease infinite;
            color: white;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: none;
            letter-spacing: 2px;
            box-shadow: 0 4px 12px rgba(210, 161, 12, 0.3);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #startBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(170, 37, 19, 0.4);
            background: linear-gradient(90deg, #D2A10C 0%, #AA2513 50%, #D2A10C 100%);
        }
        #startBtn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .start-title {
            font-size: 48px;
            font-weight: 200;
            color: #2d3748;
            margin-bottom: 20px;
            letter-spacing: 4px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            position: relative;
            z-index: 10;
        }
        .start-subtitle {
            font-size: 16px;
            font-weight: 400;
            color: #718096;
            margin-bottom: 60px;
            letter-spacing: 1px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            position: relative;
            z-index: 10;
        }

        /* Wii Fit style subtle circle decoration */
        .button-container {
            position: relative;
            display: inline-block;
            z-index: 10;
        }

        .button-circle {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid rgba(210, 161, 12, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: pulse-circle 3s ease-in-out infinite;
        }

        @keyframes pulse-circle {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.1;
            }
        }
        #webcamView {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        #webcamView.visible {
            opacity: 1;
        }
        #webcam {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            transform: scaleX(-1) translateZ(0);  /* Mirror the webcam for intuitive movement */
            -webkit-transform: scaleX(-1) translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        #processedFeed {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 2;
            opacity: 1;
            display: none;
            pointer-events: none;
            transform: scaleX(-1) translateZ(0);  /* Mirror the processed feed too */
            -webkit-transform: scaleX(-1) translateZ(0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        #canvas {
            display: none;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 400px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: none;
        }

        /* White fade transition */
        #whiteTransition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(180deg,
                rgba(255,255,255,1) 0%,
                rgba(245,247,250,1) 100%);
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: opacity;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        #whiteTransition.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Loading indicator */
        .loading-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            animation: fadeInUp 0.8s ease-out forwards;
        }

        #whiteTransition.active .loading-container {
            display: flex;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .loading-text {
            font-size: 24px;
            font-weight: 200;
            color: #4a5568;
            letter-spacing: 3px;
            margin-top: 20px;
        }

        .loading-dots {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }

        .loading-dot {
            width: 8px;
            height: 8px;
            background: #D2A10C;
            border-radius: 50%;
            animation: pulse 1.4s ease-in-out infinite;
        }

        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 60%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            30% {
                transform: scale(1.5);
                opacity: 0.7;
            }
        }

        /* Camera initialization overlay */
        #cameraInit {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0);
            backdrop-filter: blur(0px);
            -webkit-backdrop-filter: blur(0px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #cameraInit.visible {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* Exercise selection overlay */
        #exerciseSelect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
        }

        .exercise-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 27px;
            padding: 54px;
            max-width: 810px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .exercise-title {
            font-size: 38px;
            font-weight: 200;
            color: #2d3748;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }

        .exercise-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 27px;
        }

        .exercise-btn {
            background: white;
            border: 3px solid #e2e8f0;
            padding: 27px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .exercise-info {
            flex: 1;
        }

        .exercise-preview {
            width: 200px;
            height: 200px;
            position: relative;
            margin-left: 27px;
        }

        .exercise-preview img {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .exercise-preview img.active {
            opacity: 1;
        }

        .exercise-btn:hover {
            border-color: #D2A10C;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(210, 161, 12, 0.3);
        }

        .exercise-btn h3 {
            font-size: 27px;
            font-weight: 500;
            color: #2d3748;
            margin-bottom: 7px;
        }

        .exercise-btn p {
            font-size: 19px;
            color: #718096;
            margin: 0;
        }

        /* Calibration overlay - positioned at top so video is still visible */
        #calibrationOverlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1550;
            pointer-events: none;
        }

        .calibration-container {
            text-align: center;
            color: white;
            padding: 30px 40px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .calibration-title {
            font-size: 24px;
            font-weight: 200;
            letter-spacing: 6px;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .calibration-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            min-height: 40px;
        }

        .calibration-spinner {
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: calibrationSpin 1s linear infinite;
        }

        @keyframes calibrationSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .calibration-message {
            font-size: 18px;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .calibration-instruction {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 1px;
        }

        .calibration-success {
            color: #D2A10C !important;
        }

        .calibration-error {
            color: #AA2513 !important;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 50px rgba(210,161,12,0.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 0 80px rgba(210,161,12,0.8);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 50px rgba(210,161,12,0.5);
            }
        }

        /* Countdown overlay */
        #countdownOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.4); /* More transparent so you can see live tracking underneath */
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1600;
            pointer-events: none; /* Allow interaction with elements below */
        }

        .countdown-number {
            font-size: 120px;
            font-weight: 200;
            color: white;
            animation: countdownPulse 1s ease-in-out;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            width: 180px;
            height: 180px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        @keyframes countdownPulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.8;
            }
        }

        .init-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            max-width: 900px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            opacity: 0;
            transform: scale(0.95) translateY(20px);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .init-content-wrapper {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        .init-content {
            flex: 1;
            text-align: left;
        }

        .init-mascot {
            flex: 0 0 auto;
            text-align: center;
        }

        .init-mascot img {
            width: 300px;
            height: auto;
            display: block;
            margin-bottom: 5px;
            animation: gentle-wave 2s ease-in-out infinite;
        }

        .mascot-message {
            font-family: 'Kalam', cursive;
            font-size: 18px;
            color: #AA2513;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            max-width: 280px;
            margin: 0 auto;
            line-height: 1.5;
            transform: rotate(-2deg);
            letter-spacing: 0.5px;
        }

        @keyframes subtle-bounce {
            0%, 100% { transform: rotate(-2deg) translateY(0); }
            50% { transform: rotate(-2deg) translateY(-3px); }
        }

        @keyframes gentle-wave {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }

        #cameraInit.visible .init-container {
            opacity: 1;
            transform: scale(1) translateY(0);
            transition-delay: 0.3s;
        }

        .init-title {
            font-size: 28px;
            font-weight: 200;
            color: #2d3748;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-align: center;
        }

        .init-tips {
            margin: 30px 0;
            text-align: left;
        }

        .init-tip {
            display: flex;
            align-items: center;
            margin: 15px 0;
            color: #4a5568;
            font-size: 16px;
            font-weight: 300;
        }

        .tip-icon {
            width: 8px;
            height: 8px;
            background: #D2A10C;
            border-radius: 50%;
            margin-right: 20px;
            margin-left: 5px;
            flex-shrink: 0;
            opacity: 1;
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }
            100% {
                background-position: 200% 50%;
            }
        }

        .continue-btn {
            background: linear-gradient(90deg, #D2A10C 0%, #AA2513 50%, #D2A10C 100%);
            background-size: 300% 100%;
            animation: gradientFlow 12s ease-in-out infinite;
            will-change: background-position;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: block;
            margin: 30px auto 0;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .continue-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.5);
        }

        .continue-btn:active {
            transform: translateY(0);
        }

        /* ROM Progress Bar - Wii Fit / Frutiger Aero Style */
        #romProgressBar {
            position: fixed;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            height: 500px;
            width: 140px;
            background: linear-gradient(180deg,
                rgba(255, 255, 255, 0.95) 0%,
                rgba(240, 248, 255, 0.9) 50%,
                rgba(224, 247, 250, 0.95) 100%);
            backdrop-filter: blur(30px) saturate(150%);
            border-radius: 70px;
            padding: 25px;
            display: none;
            z-index: 100;
            box-shadow: 0 20px 60px rgba(0, 120, 215, 0.3),
                       0 10px 30px rgba(255, 255, 255, 0.5),
                       inset 0 2px 5px rgba(255, 255, 255, 0.9),
                       inset 0 -2px 5px rgba(0, 120, 215, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.8);
            transition: left 0.5s ease, right 0.5s ease;
        }

        /* Position on the right for LEFT arm (mirrored webcam) */
        #romProgressBar.test-left {
            left: auto;
            right: 40px;
        }

        /* Position on the left for RIGHT arm (mirrored webcam) */
        #romProgressBar.test-right {
            left: 40px;
            right: auto;
        }

        #romProgressBar.active {
            display: flex;
            flex-direction: column;
            animation: slideInLeft 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0) scale(1);
            }
        }

        .rom-header {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            font-weight: 700;
            color: #d97706;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8),
                        0 1px 3px rgba(0, 0, 0, 0.9);
        }

        .rom-bar-container {
            flex: 1;
            width: 100%;
            background: linear-gradient(180deg,
                rgba(55, 65, 81, 0.2) 0%,
                rgba(75, 85, 99, 0.3) 100%);
            border-radius: 50px;
            position: relative;
            overflow: hidden;
            border: 3px solid rgba(217, 119, 6, 0.4);
            box-shadow: inset 0 4px 12px rgba(0, 0, 0, 0.2),
                       inset 0 -2px 4px rgba(255, 255, 255, 0.5);
        }

        .rom-bar-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top,
                rgba(217, 119, 6, 0.9) 0%,
                rgba(245, 158, 11, 0.9) 30%,
                rgba(251, 191, 36, 0.9) 70%,
                rgba(253, 224, 71, 0.9) 100%);
            border-radius: 47px;
            transition: height 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 -4px 20px rgba(251, 191, 36, 0.6),
                       inset 0 3px 6px rgba(255, 255, 255, 0.5),
                       inset 0 -2px 4px rgba(217, 119, 6, 0.3);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
        }

        .rom-bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 100%;
            background: linear-gradient(180deg,
                rgba(255, 255, 255, 0.4) 0%,
                rgba(255, 255, 255, 0) 50%);
            border-radius: 47px;
        }

        .rom-markers {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .rom-marker {
            position: absolute;
            left: -5px;
            right: -5px;
            height: 2px;
            background: rgba(200, 200, 200, 0.3);
            font-size: 14px;
            font-weight: 700;
            color: #92400e;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 150px;
            text-shadow: 0 2px 4px rgba(255, 255, 255, 0.8),
                        0 1px 2px rgba(255, 255, 255, 0.9);
            background-color: rgba(255, 255, 255, 0.6);
            padding: 2px 150px 2px 5px;
            border-radius: 2px;
        }

        .rom-marker.reached {
            background: rgba(34, 197, 94, 0.9);
            height: 3px;
            color: #166534;
            font-weight: 800;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
            animation: pulse 1s;
            text-shadow: 0 2px 4px rgba(255, 255, 255, 0.9),
                        0 1px 2px rgba(255, 255, 255, 1);
        }

        @keyframes pulse {
            0% { transform: scaleX(1); }
            50% { transform: scaleX(1.05); }
            100% { transform: scaleX(1); }
        }

        .rom-marker.target {
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(217, 119, 6, 1) 20%,
                rgba(217, 119, 6, 1) 80%,
                transparent 100%);
            height: 4px;
            color: #92400e;
            font-size: 14px;
            font-weight: 800;
            box-shadow: 0 0 20px rgba(217, 119, 6, 0.6);
            z-index: 10;
            text-shadow: 0 2px 4px rgba(255, 255, 255, 0.9),
                        0 1px 2px rgba(255, 255, 255, 1);
        }

        .rom-footer {
            margin-top: 20px;
            font-size: 52px;
            font-weight: 800;
            color: #d97706;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
            text-shadow: 0 3px 10px rgba(0, 0, 0, 0.7),
                        0 1px 4px rgba(0, 0, 0, 0.8),
                        0 0 30px rgba(217, 119, 6, 0.3);
            min-height: 60px;  /* Prevent layout shift */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 10px;
            margin: 20px 10px;
        }

        .rom-instruction {
            position: fixed;
            left: 210px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg,
                rgba(255, 255, 255, 0.98) 0%,
                rgba(240, 248, 255, 0.95) 100%);
            backdrop-filter: blur(30px) saturate(150%);
            padding: 30px 40px;
            border-radius: 40px;
            color: #0078d7;
            font-size: 24px;
            font-weight: 500;
            display: none;
            max-width: 500px;
            min-width: 400px;
            border: 3px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 20px 60px rgba(0, 120, 215, 0.2),
                       0 10px 30px rgba(255, 255, 255, 0.5),
                       inset 0 2px 5px rgba(255, 255, 255, 0.9);
            letter-spacing: 0.3px;
        }

        .rom-instruction.active {
            display: block;
            animation: instructionSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes instructionSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0) scale(1);
            }
        }

        .rom-instruction .instruction-icon {
            font-size: 56px;
            margin-bottom: 20px;
            text-align: center;
            filter: drop-shadow(0 4px 8px rgba(0, 120, 215, 0.3));
        }

        .rom-instruction.positioning {
            border-color: rgba(116, 185, 255, 0.8);
            background: linear-gradient(135deg,
                rgba(250, 252, 255, 0.98) 0%,
                rgba(240, 248, 255, 0.95) 100%);
            color: #2563eb;
        }

        .rom-instruction.testing {
            border-color: rgba(46, 213, 115, 0.8);
            background: linear-gradient(135deg,
                rgba(248, 255, 252, 0.98) 0%,
                rgba(240, 255, 244, 0.95) 100%);
            color: #059669;
        }

        .rom-instruction.complete {
            border-color: rgba(129, 236, 236, 0.8);
            background: linear-gradient(135deg,
                rgba(240, 255, 255, 0.98) 0%,
                rgba(224, 247, 250, 0.95) 100%);
            color: #0891b2;
        }

        #instructionDetail {
            font-size: 18px;
            margin-top: 15px;
            font-weight: 400;
            color: currentColor;
            opacity: 0.85;
            line-height: 1.6;
        }

        .arm-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 25px;
            margin-top: 10px;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 2px 8px rgba(0, 120, 215, 0.1);
        }

        .arm-indicator.right {
            background: linear-gradient(90deg,
                rgba(116, 185, 255, 0.3) 0%,
                rgba(116, 185, 255, 0.1) 100%);
        }

        .arm-indicator.left {
            background: linear-gradient(90deg,
                rgba(46, 213, 115, 0.3) 0%,
                rgba(46, 213, 115, 0.1) 100%);
        }

        /* Assessment Report Modal */
        #assessmentReport {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .report-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
        }

        .report-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 30px;
            text-align: center;
            background: linear-gradient(90deg, #D2A10C, #AA2513);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .report-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .report-metric {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
        }

        .report-metric-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
        }

        .report-metric-value {
            font-size: 24px;
            font-weight: 700;
        }

        .report-rating {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .report-close {
            width: 100%;
            padding: 15px;
            background: linear-gradient(90deg, #D2A10C, #AA2513);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .report-close:hover {
            transform: translateY(-2px);
        }

        /* Bottom overlay bar - Enhanced with stable layout */
        #bottomOverlay {
            position: fixed !important;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            background: rgba(0, 0, 0, 0.15);  /* Much more transparent */
            display: none;
            justify-content: center;
            align-items: center;
            padding: 0;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            z-index: 1000;
            visibility: visible !important;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            /* Performance optimizations */
            transform: translate3d(0, 0, 0);  /* Force GPU layer */
            -webkit-transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            will-change: transform;
            contain: layout style paint;  /* Isolate rendering */
        }

        #repCounter {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px 24px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: none;
        }

        #repCounter .metric-value {
            font-size: 32px;
            font-weight: 300;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            letter-spacing: 0;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        #exerciseName {
            font-size: 18px;
            font-weight: 500;
            letter-spacing: 3px;
            text-transform: uppercase;
            text-align: center;
            flex-grow: 1;
            color: rgba(255,255,255,0.95);
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            transition: opacity 0.3s ease;
            min-height: 24px;
        }

        #angleDisplay {
            /* Remove all transitions */
            transition: none !important;
            animation: none !important;
            /* Force stable rendering */
            transform: translate3d(0, 0, 0);
            -webkit-transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            /* Prevent layout shifts */
            contain: strict;
            will-change: transform;
            /* Text stability */
            font-variant-numeric: tabular-nums;
            font-feature-settings: 'tnum' 1;
        }

        #exerciseName {
            /* Stable rendering for exercise name */
            transition: none !important;
            animation: none !important;
            transform: translate3d(0, 0, 0);
            -webkit-transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            contain: layout style paint;
        }

        #exerciseInstruction {
            /* Remove all transitions and animations */
            transition: none !important;
            animation: none !important;
            /* Force stable rendering */
            transform: translate3d(0, 0, 0);
            -webkit-transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            perspective: 1000px;
            /* Text rendering optimization */
            text-rendering: geometricPrecision;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            /* Prevent layout shifts */
            contain: layout style paint;
            will-change: transform;
        }

        #angleDisplay .metric-value {
            font-size: 32px;
            font-weight: 300;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            letter-spacing: 0;
            text-align: center;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }

        /* Monospace text for stable number display */
        .mono-number {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace !important;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0;
            font-feature-settings: 'tnum' 1;
        }

        /* Stable text rendering for bottom overlay */
        #bottomOverlay * {
            /* Prevent all animations and transitions */
            transition: none !important;
            animation: none !important;
            /* Force GPU acceleration */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            /* Prevent text reflow */
            text-rendering: geometricPrecision;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Animations for assessment report modal */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .metric-label {
            font-size: 12px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 4px;
            color: rgba(255,255,255,0.8);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .metric-box {
            text-align: center;
            width: 200px;
            flex-shrink: 0;
        }

        /* Progress bar - Removed as not needed */

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <!-- Technical line pattern background -->
        <div class="tech-pattern">

            <!-- Grid lines (subtle background grid) -->
            <div class="grid-lines">
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line horizontal"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
                <div class="grid-line vertical"></div>
            </div>

            <!-- Connection nodes -->
            <div class="node-grid">
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
                <div class="node"></div>
            </div>

            <!-- Connecting lines between nodes -->
            <div class="connection-lines">
                <div class="connection"></div>
                <div class="connection"></div>
                <div class="connection"></div>
                <div class="connection"></div>
                <div class="connection"></div>
                <div class="connection"></div>
                <div class="connection"></div>
                <div class="connection"></div>
            </div>

            <!-- Angle measurements -->
            <div class="angle-indicators">
                <div class="angle-indicator">
                    <svg class="angle-arc" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60">
                        <path class="arc-path" d="M 30 30 L 50 30 A 20 20 0 0 0 40 10" />
                    </svg>
                    <span class="angle-text"></span>
                </div>
                <div class="angle-indicator">
                    <svg class="angle-arc" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60">
                        <path class="arc-path" d="M 30 30 L 50 30 A 20 20 0 0 0 30 10" />
                    </svg>
                    <span class="angle-text"></span>
                </div>
                <div class="angle-indicator">
                    <svg class="angle-arc" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60">
                        <path class="arc-path" d="M 30 30 L 50 30 A 20 20 0 0 0 20 15" />
                    </svg>
                    <span class="angle-text"></span>
                </div>
                <div class="angle-indicator">
                    <svg class="angle-arc" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60">
                        <path class="arc-path" d="M 30 30 L 50 30 A 20 20 0 0 0 35 15" />
                    </svg>
                    <span class="angle-text"></span>
                </div>
            </div>

            <!-- Floating calculation numbers -->
            <div class="calc-numbers">
                <div class="calc-num"></div>
                <div class="calc-num"></div>
                <div class="calc-num"></div>
                <div class="calc-num"></div>
                <div class="calc-num"></div>
            </div>
        </div>

        <!-- Main content -->
        <div class="start-title">KINEXIS</div>
        <div class="start-subtitle">Physical Therapy Recovery System</div>
        <div class="button-container">
            <div class="button-circle"></div>
            <button id="startBtn" onclick="startPoseDetection()">Start</button>
        </div>
    </div>

    <!-- White transition overlay -->
    <div id="whiteTransition">
        <div class="loading-container">
            <div class="loading-text">INITIALIZING</div>
            <div class="loading-dots">
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
            </div>
        </div>
    </div>

    <div id="webcamView">
        <video id="webcam" autoplay muted></video>
        <canvas id="canvas"></canvas>
        <img id="processedFeed" alt="Processed video">
        <div id="info">
            <div id="status">Connecting...</div>
            <div id="instructions" style="margin-top: 10px; font-size: 16px; color: #D2A10C;">
                • Stand 5-8 feet back from camera<br>
                • Ensure your FULL BODY is visible<br>
                • Good lighting helps detection
            </div>
        </div>

        <!-- Camera initialization overlay -->
        <div id="cameraInit">
            <div class="init-container">
                <div class="init-content-wrapper">
                    <div class="init-content">
                        <div class="init-title">PREPARING YOUR SESSION</div>
                        <div class="init-tips">
                            <div class="init-tip">
                                <div class="tip-icon"></div>
                                <div>Stand 5-8 feet back from your camera</div>
                            </div>
                            <div class="init-tip">
                                <div class="tip-icon"></div>
                                <div>Ensure your full body is visible in frame</div>
                            </div>
                            <div class="init-tip">
                                <div class="tip-icon"></div>
                                <div>Good lighting improves tracking accuracy</div>
                            </div>
                            <div class="init-tip">
                                <div class="tip-icon"></div>
                                <div>Wear fitted clothing for best results</div>
                            </div>
                        </div>
                        <button class="continue-btn" onclick="showExerciseSelection()">Continue</button>
                    </div>
                    <div class="init-mascot">
                        <img src="/static/logowave.png" alt="Kinexis Mascot" />
                        <div class="mascot-message">Your friendly coach will guide you through each exercise!</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Exercise selection overlay -->
        <div id="exerciseSelect">
            <div class="exercise-container">
                <div class="exercise-title">SELECT YOUR EXERCISE</div>
                <div class="exercise-grid">
                    <div class="exercise-btn" onclick="selectExercise('shoulder_abduction')">
                        <div class="exercise-info">
                            <h3>Shoulder Abduction</h3>
                            <p>Raise your arm out to the side • Standing position</p>
                        </div>
                        <div class="exercise-preview" id="shoulderAbductionPreview">
                            <img src="/static/arm1.png" class="active" alt="Shoulder Abduction Frame 1">
                            <img src="/static/arm2.png" alt="Shoulder Abduction Frame 2">
                            <img src="/static/arm3.png" alt="Shoulder Abduction Frame 3">
                        </div>
                    </div>
                    <div class="exercise-btn" onclick="selectExercise('knee_flexion')">
                        <div class="exercise-info">
                            <h3>Knee Flexion</h3>
                            <p>Bend your knee while seated • Side view</p>
                        </div>
                        <div class="exercise-preview" id="kneeFlexionPreview">
                            <img src="/static/sit1.png" class="active" alt="Knee Flexion Frame 1">
                            <img src="/static/sit2.png" alt="Knee Flexion Frame 2">
                            <img src="/static/sit3.png" alt="Knee Flexion Frame 3">
                        </div>
                    </div>
                    <div class="exercise-btn" onclick="selectExercise('shoulder_flexion')">
                        <div class="exercise-info">
                            <h3>Shoulder Flexion</h3>
                            <p>Raise your arm forward and up • Standing position</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calibration overlay -->
        <div id="calibrationOverlay">
            <div class="calibration-container">
                <div class="calibration-title">CALIBRATING</div>
                <div class="calibration-status" id="calibrationStatus">
                    <div class="calibration-spinner"></div>
                    <div class="calibration-message">Checking body detection...</div>
                </div>
                <div class="calibration-instruction">Please ensure your entire body is visible in the frame</div>
            </div>
        </div>

        <!-- Countdown overlay -->
        <div id="countdownOverlay">
            <div class="countdown-number" id="countdownNumber">3</div>
        </div>

        <!-- Bottom overlay -->
        <div id="bottomOverlay">
            <div style="display: grid; grid-template-rows: 26px 50px 34px; width: 100%; height: 100%; place-items: center; padding: 20px 0 10px 0; gap: 8px; position: relative;">
                <div id="exerciseName" style="font-size: 15px; color: #ffffff; letter-spacing: 3px; text-transform: uppercase; font-weight: 700; width: 100%; height: 26px; display: grid; place-items: center; font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif; line-height: 1.5; text-shadow: 0 0 10px rgba(0,0,0,0.9), 0 2px 6px rgba(0,0,0,0.8);">SHOULDER ABDUCTION</div>
                <div id="exerciseInstruction" style="font-size: 36px; font-weight: 700; color: #ffffff; text-shadow: 0 0 12px rgba(0,0,0,0.95), 0 2px 8px rgba(0,0,0,0.8), 0 4px 12px rgba(0,0,0,0.6); width: 90%; max-width: 1000px; height: 50px; display: grid; place-items: center; white-space: nowrap; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', 'Segoe UI', sans-serif; overflow: hidden; position: relative; -webkit-text-stroke: 0.5px rgba(0,0,0,0.3);">Ready to begin</div>
                <div id="angleDisplay" style="font-size: 26px; color: #fef08a; font-family: 'SF Mono', Monaco, monospace; width: 700px; height: 34px; display: grid; place-items: center; font-weight: 600; text-shadow: 0 0 10px rgba(0,0,0,0.95), 0 2px 6px rgba(0,0,0,0.8); white-space: nowrap; letter-spacing: 0.5px; position: relative; -webkit-text-stroke: 0.3px rgba(0,0,0,0.2);"></div>
            </div>
        </div>

        <!-- Hold Timer Countdown Display -->
        <div id="holdCountdown" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                        display: none; z-index: 1000; text-align: center;
                                        background: rgba(0,0,0,0.8); padding: 40px; border-radius: 20px;
                                        border: 3px solid #D2A10C; box-shadow: 0 0 50px rgba(210,161,12,0.5);">
            <div style="font-size: 24px; color: #D2A10C; margin-bottom: 10px; font-weight: 600;">HOLD POSITION!</div>
            <div id="holdCountdownNumber" style="font-size: 72px; color: #4ade80; font-weight: bold;
                                             text-shadow: 0 0 20px rgba(74,222,128,0.5);">5</div>
            <div id="maxAngleDisplay" style="font-size: 20px; color: #fff; margin-top: 10px;">Max: 0°</div>
            <div style="font-size: 16px; color: #aaa; margin-top: 10px;">Keep your arm steady at this height</div>
        </div>

        <!-- Arms Down Instruction Figure -->
        <div id="armsDownFigure" style="position: fixed; right: 40px; top: 50%; transform: translateY(-50%);
                                        display: none; z-index: 999; width: 380px; height: 380px;">
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="color: #fbbf24; font-size: 24px; font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,0.4);">
                    LOWER ARMS TO SIDES
                </div>
                <div style="color: #fff; font-size: 16px; margin-top: 8px; opacity: 0.9;">
                    Hold this position for 2 seconds
                </div>
            </div>
            <div id="armsDownAnimation" style="position: relative; width: 380px; height: 300px;
                                               border: 3px solid rgba(251, 191, 36, 0.5);
                                               border-radius: 20px; padding: 15px;
                                               background: rgba(0,0,0,0.5);
                                               box-shadow: 0 0 30px rgba(251, 191, 36, 0.2);">
                <img src="/static/arm2.png" class="arms-down-frame active" alt="Arms Down Frame 1"
                     style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                            object-fit: contain; transition: opacity 0.5s;">
                <img src="/static/arm1.png" class="arms-down-frame" alt="Arms Down Frame 2"
                     style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                            object-fit: contain; opacity: 0; transition: opacity 0.5s;">
            </div>
        </div>
    </div>

    <!-- ROM Progress Bar - Modern Design -->
    <div id="romProgressBar">
        <div class="rom-header">RANGE OF MOTION</div>
        <div class="rom-bar-container">
            <div class="rom-bar-fill" id="romBarFill" style="height: 0%"></div>
            <div class="rom-markers">
                <div class="rom-marker" id="marker-10" style="bottom: 5.5%;">10°</div>
                <div class="rom-marker" id="marker-20" style="bottom: 11%;">20°</div>
                <div class="rom-marker" id="marker-30" style="bottom: 16.5%;">30°</div>
                <div class="rom-marker" id="marker-40" style="bottom: 22%;">40°</div>
                <div class="rom-marker" id="marker-50" style="bottom: 27.5%;">50°</div>
                <div class="rom-marker" id="marker-60" style="bottom: 33%;">60°</div>
                <div class="rom-marker" id="marker-70" style="bottom: 38.5%;">70°</div>
                <div class="rom-marker" id="marker-80" style="bottom: 44%;">80°</div>
                <div class="rom-marker" id="marker-90" style="bottom: 50%;">90°</div>
                <div class="rom-marker" id="marker-100" style="bottom: 55.5%;">100°</div>
                <div class="rom-marker" id="marker-110" style="bottom: 61%;">110°</div>
                <div class="rom-marker" id="marker-120" style="bottom: 66.5%;">120°</div>
                <div class="rom-marker" id="marker-130" style="bottom: 72%;">130°</div>
                <div class="rom-marker" id="marker-140" style="bottom: 77.5%;">140°</div>
                <div class="rom-marker target" id="marker-150" style="bottom: 83%;">TARGET</div>
                <div class="rom-marker" id="marker-160" style="bottom: 88.5%;">160°</div>
                <div class="rom-marker" id="marker-170" style="bottom: 94%;">170°</div>
            </div>
        </div>
        <div class="rom-footer" id="currentAngleDisplay">0°</div>
    </div>

    <div class="rom-instruction" id="romInstruction">
        <div class="instruction-icon" id="instructionIcon"></div>
        <div id="instructionText"></div>
        <div id="instructionDetail"></div>
    </div>

    <!-- Assessment Report Modal -->
    <div id="assessmentReport">
        <div class="report-content">
            <h2 class="report-title">PT Assessment Complete</h2>
            <div class="report-metrics" id="reportMetrics"></div>
            <div class="report-rating" id="reportRating"></div>
            <button class="report-close" onclick="closeReport()">Close Report</button>
        </div>
    </div>

    <!-- Audio elements for calibration sounds -->
    <audio id="calibrationCompleteSound" src="/static/audio/calibration_complete.wav" preload="auto"></audio>
    <audio id="calibrationErrorSound" src="/static/audio/calibration_error.wav" preload="auto"></audio>
    <audio id="progbarSound" src="/static/audio/progbar.wav" preload="auto"></audio>

    <script>
        const socket = io('http://localhost:5001');
        let isProcessing = false;
        let sessionKey = 'test_session';

        socket.on('connect', () => {
            console.log('Connected to backend');
        });

        // Animate exercise preview images on hover
        let kneeAnimationInterval = null;
        let kneeCurrentIndex = 0;
        let shoulderAnimationInterval = null;
        let shoulderCurrentIndex = 0;

        function startKneeAnimation() {
            const preview = document.getElementById('kneeFlexionPreview');
            if (!preview) return;

            const images = preview.querySelectorAll('img');

            // Clear any existing animation
            if (kneeAnimationInterval) {
                clearInterval(kneeAnimationInterval);
            }

            // Animation loop
            kneeAnimationInterval = setInterval(() => {
                // Remove active class from current image
                images[kneeCurrentIndex].classList.remove('active');

                // Move to next image
                kneeCurrentIndex = (kneeCurrentIndex + 1) % images.length;

                // Add active class to new image
                images[kneeCurrentIndex].classList.add('active');
            }, 500); // Change frame every 500ms
        }

        function stopKneeAnimation() {
            const preview = document.getElementById('kneeFlexionPreview');
            if (!preview) return;

            // Clear animation
            if (kneeAnimationInterval) {
                clearInterval(kneeAnimationInterval);
                kneeAnimationInterval = null;
            }

            // Reset to first frame
            const images = preview.querySelectorAll('img');
            images.forEach((img, index) => {
                img.classList.toggle('active', index === 0);
            });
            kneeCurrentIndex = 0;
        }

        function startShoulderAnimation() {
            const preview = document.getElementById('shoulderAbductionPreview');
            if (!preview) return;

            const images = preview.querySelectorAll('img');

            // Clear any existing animation
            if (shoulderAnimationInterval) {
                clearInterval(shoulderAnimationInterval);
            }

            // Animation loop
            shoulderAnimationInterval = setInterval(() => {
                // Remove active class from current image
                images[shoulderCurrentIndex].classList.remove('active');

                // Move to next image
                shoulderCurrentIndex = (shoulderCurrentIndex + 1) % images.length;

                // Add active class to new image
                images[shoulderCurrentIndex].classList.add('active');
            }, 500); // Change frame every 500ms
        }

        function stopShoulderAnimation() {
            const preview = document.getElementById('shoulderAbductionPreview');
            if (!preview) return;

            // Clear animation
            if (shoulderAnimationInterval) {
                clearInterval(shoulderAnimationInterval);
                shoulderAnimationInterval = null;
            }

            // Reset to first frame
            const images = preview.querySelectorAll('img');
            images.forEach((img, index) => {
                img.classList.toggle('active', index === 0);
            });
            shoulderCurrentIndex = 0;
        }

        // Set up hover events when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Animation only on hover for knee flexion
            const kneeFlexionBtn = document.querySelector('[onclick="selectExercise(\'knee_flexion\')"]');
            if (kneeFlexionBtn) {
                kneeFlexionBtn.addEventListener('mouseenter', startKneeAnimation);
                kneeFlexionBtn.addEventListener('mouseleave', stopKneeAnimation);
            }

            // Animation only on hover for shoulder abduction
            const shoulderAbductionBtn = document.querySelector('[onclick="selectExercise(\'shoulder_abduction\')"]');
            if (shoulderAbductionBtn) {
                shoulderAbductionBtn.addEventListener('mouseenter', startShoulderAnimation);
                shoulderAbductionBtn.addEventListener('mouseleave', stopShoulderAnimation);
            }
        });

        async function startPoseDetection() {
            // Show white transition with loading
            const whiteTransition = document.getElementById('whiteTransition');
            whiteTransition.classList.add('active');

            // Wait for fade in to complete
            await new Promise(resolve => setTimeout(resolve, 800));

            // Hide start screen, show webcam view
            document.getElementById('startScreen').style.display = 'none';
            const webcamView = document.getElementById('webcamView');
            webcamView.style.display = 'block';

            // Initialize webcam
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 1280,
                        height: 720
                    }
                });
                document.getElementById('webcam').srcObject = stream;

                // Wait for camera to fully initialize
                await new Promise(resolve => setTimeout(resolve, 1500));

                // Fade in webcam view
                webcamView.classList.add('visible');

                // Update loading text
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = 'READY';
                }

                // Wait a moment to show ready state
                await new Promise(resolve => setTimeout(resolve, 500));

                // Fade out white transition smoothly
                whiteTransition.classList.remove('active');

                // Wait for fade out to complete
                await new Promise(resolve => setTimeout(resolve, 1500));

                // Show camera initialization overlay with smooth animation
                const cameraInit = document.getElementById('cameraInit');
                cameraInit.style.display = 'flex';

                // Trigger the animation after a brief delay
                await new Promise(resolve => setTimeout(resolve, 50));
                cameraInit.classList.add('visible');

            } catch (error) {
                document.getElementById('info').innerText = 'Error: Cannot access webcam';
                console.error('Webcam error:', error);
                whiteTransition.classList.remove('active');
            }
        }

        // Function to show exercise selection after camera setup
        async function showExerciseSelection() {
            // Fade out camera init overlay
            const cameraInit = document.getElementById('cameraInit');
            cameraInit.classList.remove('visible');

            // Wait for fade out animation
            await new Promise(resolve => setTimeout(resolve, 500));
            cameraInit.style.display = 'none';

            // Show exercise selection overlay
            const exerciseSelect = document.getElementById('exerciseSelect');
            exerciseSelect.style.display = 'flex';
            exerciseSelect.style.opacity = '0';

            // Set up hover events for knee flexion animation
            const kneeFlexionBtn = document.querySelector('[onclick="selectExercise(\'knee_flexion\')"]');
            if (kneeFlexionBtn) {
                kneeFlexionBtn.addEventListener('mouseenter', startKneeAnimation);
                kneeFlexionBtn.addEventListener('mouseleave', stopKneeAnimation);
            }

            // Set up hover events for shoulder abduction animation
            const shoulderAbductionBtn = document.querySelector('[onclick="selectExercise(\'shoulder_abduction\')"]');
            if (shoulderAbductionBtn) {
                shoulderAbductionBtn.addEventListener('mouseenter', startShoulderAnimation);
                shoulderAbductionBtn.addEventListener('mouseleave', stopShoulderAnimation);
            }

            // Trigger fade in
            requestAnimationFrame(() => {
                exerciseSelect.style.transition = 'opacity 0.6s ease-in-out';
                exerciseSelect.style.opacity = '1';
            });
        }

        // Function to handle exercise selection and start calibration
        async function selectExercise(exerciseType) {
            // Store selected exercise
            sessionStorage.setItem('currentExercise', exerciseType);

            // Reset ROM display for shoulder abduction
            if (exerciseType === 'shoulder_abduction') {
                resetROMDisplay();
            }

            // Special instructions for knee flexion
            let instructionText = '';
            if (exerciseType === 'knee_flexion') {
                instructionText = 'Please sit down and turn to your side';
            } else {
                instructionText = 'Please stand in view of the camera';
            }

            // Hide exercise selection
            const exerciseSelect = document.getElementById('exerciseSelect');
            exerciseSelect.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 500));
            exerciseSelect.style.display = 'none';

            // Show positioning instruction briefly if needed
            if (instructionText) {
                const bottomOverlay = document.getElementById('bottomOverlay');
                const exerciseName = document.getElementById('exerciseName');

                // Temporarily show instruction
                bottomOverlay.style.display = 'flex';
                bottomOverlay.style.opacity = '1';
                exerciseName.textContent = instructionText.toUpperCase();

                // Wait for user to get in position
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            // Start calibration
            const calibrationSuccess = await performCalibration(exerciseType);

            if (calibrationSuccess) {
                // Skip countdown - go directly to exercise tracking
                // await startCountdown();  // Removed per user request

                // Start the actual exercise tracking immediately
                await startTracking(exerciseType);
            } else {
                // Allow user to try again
                console.log('Calibration failed - user should reposition');
                // Show exercise selection again
                exerciseSelect.style.display = 'flex';
                exerciseSelect.style.opacity = '1';
            }
        }

        // Calibration function
        async function performCalibration(exerciseType) {
            const calibrationOverlay = document.getElementById('calibrationOverlay');
            const calibrationStatus = document.getElementById('calibrationStatus');
            const bottomOverlay = document.getElementById('bottomOverlay');
            const processedFeed = document.getElementById('processedFeed');

            // Temporarily stop regular frame processing to prevent lag
            const wasProcessing = isProcessing;
            isProcessing = false;

            // IMPORTANT: Hide and clear processed feed to show live camera during calibration
            processedFeed.style.display = 'none';
            processedFeed.src = '';  // Clear any frozen frame

            // Show calibration overlay (at top, video still visible)
            calibrationOverlay.style.display = 'block';
            calibrationOverlay.style.opacity = '0';

            // Fade in
            requestAnimationFrame(() => {
                calibrationOverlay.style.transition = 'opacity 0.5s ease-in-out';
                calibrationOverlay.style.opacity = '1';
            });

            await new Promise(resolve => setTimeout(resolve, 500));

            // Give user time to see themselves and get in position
            calibrationStatus.innerHTML = `
                <div class="calibration-spinner"></div>
                <div class="calibration-message">Get in position - full body visible</div>
            `;

            // Wait 3 seconds for user to get ready
            await new Promise(resolve => setTimeout(resolve, 3000));

            // Update message
            calibrationStatus.innerHTML = `
                <div class="calibration-spinner"></div>
                <div class="calibration-message">Detecting your body...</div>
                <div style="margin-top: 10px; font-size: 14px; color: #ccc;">Attempting multiple frames for better detection</div>
            `;

            // Do a single check instead of multiple to prevent lag
            let bodyDetected = false;

            // Create a promise that resolves when we get a successful pose detection
            const checkBodyDetection = new Promise((resolve) => {
                let calibrationReceived = false;

                // Set up one-time listener for the calibration check
                const calibrationHandler = (data) => {
                    // Only process if we haven't already received a calibration response
                    if (calibrationReceived) return;

                    console.log('Frame response received during calibration:', {
                        hasData: !!data,
                        hasMeasurements: !!(data && data.measurements),
                        hasCalibrationStatus: !!(data && data.measurements && data.measurements.calibration_status),
                        calibrationStatus: data?.measurements?.calibration_status,
                        fullMeasurements: data?.measurements
                    });

                    // Only process frames that have calibration_status (ignore regular frames)
                    if (data && data.measurements && data.measurements.calibration_status) {
                        calibrationReceived = true;
                        socket.off('frame_processed', calibrationHandler);

                        if (data.measurements.calibration_status === 'success') {
                            console.log('✓ Calibration SUCCESS! Body detected with', data.measurements.visible_landmarks, 'landmarks');
                            resolve(true);
                        } else {
                            console.log('✗ Calibration failed:', data.measurements.error || 'Body not fully visible');
                            resolve(false);
                        }
                    }
                    // If no calibration_status, this is a regular frame - just ignore it
                };

                socket.on('frame_processed', calibrationHandler);

                // Send MULTIPLE frames for better detection
                const video = document.getElementById('webcam');
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');

                let calibrationAttempts = 0;
                const maxAttempts = 10; // Try up to 10 frames
                const attemptInterval = 300; // ms between attempts

                // Function to send calibration frames
                const sendCalibrationFrame = () => {
                    // Check if we already got a response
                    if (calibrationReceived) {
                        console.log('✅ Calibration already received, stopping attempts');
                        return;
                    }

                    calibrationAttempts++;
                    console.log(`🎯 Calibration attempt ${calibrationAttempts}/${maxAttempts}`);

                    // Update UI to show attempt counter
                    const calibrationStatus = document.getElementById('calibrationStatus');
                    if (calibrationStatus) {
                        calibrationStatus.innerHTML = `
                            <div class="calibration-spinner"></div>
                            <div class="calibration-message">Detecting your body...</div>
                            <div style="margin-top: 10px; font-size: 14px; color: #ccc;">
                                Attempt ${calibrationAttempts} of ${maxAttempts}
                            </div>
                        `;
                    }

                    if (!video || !canvas || !ctx) {
                        console.log('❌ Video/Canvas/Context not available');
                        resolve(false);
                        return;
                    }

                    if (calibrationAttempts > maxAttempts) {
                        console.log('❌ Max calibration attempts reached');
                        if (!calibrationReceived) {
                            socket.off('frame_processed', calibrationHandler);
                            resolve(false);
                        }
                        return;
                    }

                    // Try to capture and send frame
                    try {
                        // Use simpler resolution for reliability
                        canvas.width = 640;
                        canvas.height = 480;
                        ctx.drawImage(video, 0, 0, 640, 480);

                        const imageData = canvas.toDataURL('image/jpeg', 0.9);

                        console.log(`📸 SENDING CALIBRATION FRAME #${calibrationAttempts}`);

                        socket.emit('process_frame', {
                            session_key: sessionKey,
                            exercise_type: exerciseType,
                            image: imageData,
                            is_calibration: true  // Mark as calibration to check body detection
                        });

                        // Schedule next attempt if we don't get a response
                        setTimeout(() => {
                            if (!calibrationReceived && calibrationAttempts < maxAttempts) {
                                console.log(`⏳ No response yet, sending next frame...`);
                                sendCalibrationFrame();
                            }
                        }, attemptInterval);

                    } catch (error) {
                        console.error('❌ Error sending calibration frame:', error);

                        // Try again after a delay if we have attempts left
                        if (calibrationAttempts < maxAttempts) {
                            setTimeout(() => {
                                sendCalibrationFrame();
                            }, attemptInterval);
                        } else {
                            resolve(false);
                        }
                    }
                };

                // Start sending calibration frames after a short delay
                setTimeout(() => {
                    sendCalibrationFrame();
                }, 100);

                // Timeout after 3 seconds if no calibration response
                setTimeout(() => {
                    if (!calibrationReceived) {
                        console.log('Calibration timeout - no response received');
                        socket.off('frame_processed', calibrationHandler);
                        resolve(false);
                    }
                }, 3000);
            });

            // Wait for body detection result
            const calibrationSuccess = await checkBodyDetection;

            // Update UI based on calibration result
            if (calibrationSuccess) {
                // Success feedback
                calibrationStatus.innerHTML = `
                    <div style="font-size: 48px;">✓</div>
                    <div class="calibration-message calibration-success">Calibration Complete</div>
                `;

                // Play success sound
                const successSound = document.getElementById('calibrationCompleteSound');
                try {
                    await successSound.play();
                } catch (e) {
                    console.log('Could not play calibration sound:', e);
                }

                // DON'T show static processed feed - let live tracking start immediately
                // processedFeed.style.display = 'block';  // REMOVED - no static screenshot

                // Start processing frames immediately so live feed is visible during countdown
                isProcessing = true;
                requestAnimationFrame(() => {
                    processFrames();
                });

                // Brief pause just to show success message
                await new Promise(resolve => setTimeout(resolve, 800));
            } else {
                // Error feedback with helpful tips
                calibrationStatus.innerHTML = `
                    <div style="font-size: 48px; color: #f87171;">✗</div>
                    <div class="calibration-message calibration-error">Body Not Detected</div>
                    <div style="margin-top: 15px; font-size: 14px; color: #ccc; max-width: 400px;">
                        <strong>Tips:</strong><br>
                        • Stand further back (6-8 feet)<br>
                        • Ensure your full body is visible<br>
                        • Try better lighting<br>
                        • Wear fitted clothing
                    </div>
                `;

                // Play error sound
                const errorSound = document.getElementById('calibrationErrorSound');
                try {
                    await errorSound.play();
                } catch (e) {
                    console.log('Could not play calibration sound:', e);
                }

                // IMPORTANT: Keep processed feed hidden on failure so user can see live camera for retry
                processedFeed.style.display = 'none';
                processedFeed.src = '';  // Clear any failed frame

                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            // Hide calibration overlay
            calibrationOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 500));
            calibrationOverlay.style.display = 'none';

            // Reset calibration UI for next time
            calibrationStatus.innerHTML = `
                <div class="calibration-spinner"></div>
                <div class="calibration-message">Checking body detection...</div>
            `;

            // Restore processing state if it was on
            if (wasProcessing) {
                isProcessing = true;
            }

            return calibrationSuccess;
        }

        // Countdown function
        // Function kept for potential future use, but currently disabled - goes directly from calibration to exercise
        async function startCountdown() {
            const countdownOverlay = document.getElementById('countdownOverlay');
            const countdownNumber = document.getElementById('countdownNumber');

            // Show countdown overlay
            countdownOverlay.style.display = 'flex';
            countdownOverlay.style.opacity = '0';

            // Fade in
            requestAnimationFrame(() => {
                countdownOverlay.style.transition = 'opacity 0.3s ease-in-out';
                countdownOverlay.style.opacity = '1';
            });

            await new Promise(resolve => setTimeout(resolve, 300));

            // Count from 3 to 1
            for (let i = 3; i >= 1; i--) {
                countdownNumber.textContent = i;
                countdownNumber.style.animation = 'none';

                // Force reflow to restart animation
                void countdownNumber.offsetWidth;
                countdownNumber.style.animation = 'countdownPulse 0.8s ease-out';

                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // Fade out countdown
            countdownOverlay.style.opacity = '0';
            await new Promise(resolve => setTimeout(resolve, 300));
            countdownOverlay.style.display = 'none';
        }

        async function startTracking(exerciseType = null) {
            // Get exercise type from parameter or session storage
            const currentExercise = exerciseType || sessionStorage.getItem('currentExercise') || 'shoulder_abduction';

            // Show ROM bar and starting position instruction for shoulder abduction
            if (currentExercise === 'shoulder_abduction') {
                // Show ROM progress bar immediately
                document.getElementById('romProgressBar').classList.add('active');

                // Show starting position instruction with specific arm guidance
                const instruction = document.getElementById('romInstruction');
                const instructionText = document.getElementById('instructionText');
                const instructionDetail = document.getElementById('instructionDetail');
                const instructionIcon = document.getElementById('instructionIcon');

                instruction.className = 'rom-instruction active positioning';
                instructionIcon.textContent = '🧍';
                instructionText.innerHTML = 'Starting Position';
                instructionDetail.innerHTML = `
                    <div>Stand up straight, feet shoulder-width apart</div>
                    <div class="arm-indicator right" style="margin-top: 12px;">
                        <span>➡️</span> RIGHT ARM: Keep at your side, palm facing your leg
                    </div>
                    <div style="margin-top: 10px; font-size: 16px; opacity: 0.7;">Ready in 3 seconds...</div>
                `;

                // Wait for positioning
                await new Promise(resolve => setTimeout(resolve, 3000));

                // Update instruction to begin exercise with specific arm movement
                instruction.className = 'rom-instruction active testing';
                instructionIcon.textContent = '💪';
                instructionText.innerHTML = 'Raise Your Right Arm';
                instructionDetail.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 10px;">Movement Instructions:</div>
                    <div>1️⃣ Keep your arm straight</div>
                    <div>2️⃣ Raise it OUT TO THE SIDE (not forward)</div>
                    <div>3️⃣ Go slowly and smoothly to 150°</div>
                    <div class="arm-indicator right" style="margin-top: 12px;">
                        <span>🎯</span> Target: 150° (shoulder height and above)
                    </div>
                `;
            }

            // Emit start_exercise event to reset backend assessment
            socket.emit('start_exercise', {
                session_id: sessionKey,
                exercise_type: currentExercise
            });
            console.log('🚀 Started exercise:', currentExercise);

            // Initialize the bottom overlay with proper exercise name
            const exerciseNames = {
                'shoulder_abduction': 'SHOULDER ABDUCTION',
                'knee_flexion': 'KNEE FLEXION',
                'shoulder_flexion': 'SHOULDER FLEXION'
            };

            // Set exercise name immediately (no more DEMO MODE)
            document.getElementById('exerciseName').textContent = exerciseNames[currentExercise];

            // Initialize the bottom overlay with default values
            updateBottomOverlay(0, 0, 0, 150);

            // Make sure bottom overlay is visible with smooth fade
            const bottomOverlay = document.getElementById('bottomOverlay');
            bottomOverlay.style.display = 'flex';
            bottomOverlay.style.opacity = '0';

            // Use requestAnimationFrame for smooth transition
            requestAnimationFrame(() => {
                bottomOverlay.style.transition = 'opacity 0.5s ease-in-out';
                bottomOverlay.style.opacity = '1';
            });

            // Pre-warm the video processing by doing a test frame
            const video = document.getElementById('webcam');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Do a test draw to warm up the pipeline
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = 640;
                canvas.height = 480;
                ctx.drawImage(video, 0, 0, 640, 480);
            }

            // Wait a bit more to ensure smooth transition
            await new Promise(resolve => setTimeout(resolve, 500));

            // Start sending frames after everything is settled
            isProcessing = true;

            // Use requestAnimationFrame to start on next frame for smoothness
            requestAnimationFrame(() => {
                processFrames();
            });
        }

        let frameCount = 0;

        function processFrames() {
            if (!isProcessing) return;

            const video = document.getElementById('webcam');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Make sure video is ready
            if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                requestAnimationFrame(() => {
                    setTimeout(processFrames, 50);
                });
                return;
            }

            // Don't skip frames - process continuously for smooth tracking

            // Skip first few frames to let things stabilize
            frameCount++;
            if (frameCount < 5) {
                requestAnimationFrame(() => {
                    setTimeout(processFrames, 100);
                });
                return;
            }

            // Preserve aspect ratio when resizing
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const aspectRatio = videoWidth / videoHeight;

            // Target max dimension while preserving aspect ratio
            let targetWidth, targetHeight;
            const maxDimension = 960; // Higher resolution for better quality

            if (videoWidth > videoHeight) {
                targetWidth = Math.min(videoWidth, maxDimension);
                targetHeight = Math.round(targetWidth / aspectRatio);
            } else {
                targetHeight = Math.min(videoHeight, maxDimension);
                targetWidth = Math.round(targetHeight * aspectRatio);
            }

            canvas.width = targetWidth;
            canvas.height = targetHeight;

            // Draw with proper aspect ratio
            ctx.clearRect(0, 0, targetWidth, targetHeight);
            ctx.drawImage(video, 0, 0, targetWidth, targetHeight);

            // Better quality for clearer image (0.85 for good balance)
            const imageData = canvas.toDataURL('image/jpeg', 0.85);

            // Send frame to backend
            const currentExercise = sessionStorage.getItem('currentExercise') || 'shoulder_abduction';
            socket.emit('process_frame', {
                session_key: sessionKey,
                exercise_type: currentExercise,
                image: imageData
            });

            // Process at 30 FPS with optimized model using requestAnimationFrame
            requestAnimationFrame(() => {
                setTimeout(processFrames, 33);
            });
        }

        // Track last increment to avoid duplicate sounds
        let lastIncrementPlayed = 0;

        // Handle processed frames
        socket.on('frame_processed', (data) => {

            if (data.processed_image) {
                const img = document.getElementById('processedFeed');
                img.src = data.processed_image;
                img.style.display = 'block';
            }

            if (data.measurements) {
                if (data.measurements.error) {
                    // Show connection status when not tracking
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('status').innerHTML =
                        `${data.measurements.error}`;
                    document.getElementById('instructions').style.display = 'block';

                    // Reset bottom overlay to default state when no tracking
                    updateBottomOverlay(0, 0, 0, 150);
                } else {
                    // Hide the top info when tracking is active
                    document.getElementById('info').style.display = 'none';

                    const currentExercise = sessionStorage.getItem('currentExercise');

                    // Check if this is shoulder abduction (always show ROM bar)
                    if (currentExercise === 'shoulder_abduction') {
                        // Show ROM bar for shoulder abduction
                        document.getElementById('romProgressBar').classList.add('active');

                        // Update ROM bar
                        const angle = data.measurements.active_angle || 0;
                        const romPercentage = Math.min(100, (angle / 180) * 100);
                        document.getElementById('romBarFill').style.height = `${romPercentage}%`;

                        // Track previous angle for threshold crossing detection
                        if (!window.previousAngle) {
                            window.previousAngle = 0;
                        }

                        // Check if we crossed a 10-degree threshold
                        const threshold = 10; // Play sound every 10 degrees
                        const previousThreshold = Math.floor(window.previousAngle / threshold);
                        const currentThreshold = Math.floor(angle / threshold);

                        // Play sound when crossing upward through a threshold
                        if (currentThreshold > previousThreshold && angle > window.previousAngle) {
                            const progbarSound = document.getElementById('progbarSound');
                            if (progbarSound) {
                                progbarSound.currentTime = 0;
                                progbarSound.volume = 0.3; // Moderate volume for frequent playing
                                progbarSound.play().catch(e => console.log('Progbar sound play failed:', e));
                            }

                            // Also briefly highlight the marker we just crossed
                            const crossedDegrees = currentThreshold * threshold;
                            const markerElement = document.getElementById(`marker-${crossedDegrees}`);
                            if (markerElement) {
                                markerElement.style.color = '#4ade80';
                                markerElement.style.fontWeight = 'bold';
                                markerElement.style.transform = 'scale(1.2)';
                                setTimeout(() => {
                                    markerElement.style.color = '';
                                    markerElement.style.fontWeight = '';
                                    markerElement.style.transform = '';
                                }, 500);
                            }
                        }

                        // Update previous angle for next comparison
                        window.previousAngle = angle;

                        // Update current angle display with fixed width to prevent jumping
                        const roundedAngle = Math.round(angle);
                        const paddedAngle = roundedAngle.toString().padStart(3, ' ');
                        document.getElementById('currentAngleDisplay').innerHTML = `<span style="display: inline-block; min-width: 4ch; text-align: right;">${paddedAngle}°</span>`;

                        // Update bottom overlay with instruction and angle
                        if (data.measurements.instruction) {
                            const exerciseInstructionElement = document.getElementById('exerciseInstruction');
                            const angleDisplayElement = document.getElementById('angleDisplay');
                            const currentAngle = Math.round(data.measurements.active_angle || 0);

                            // Display the instruction from backend (with stable update)
                            if (exerciseInstructionElement.textContent !== data.measurements.instruction) {
                                // Use innerHTML with a span to maintain consistent layout
                                exerciseInstructionElement.innerHTML = `<span style="display: block; width: 100%; text-align: center;">${data.measurements.instruction}</span>`;
                            }

                            // Display current angle and best angle with fixed layout
                            if (data.measurements.assessment_state !== 'arms_at_sides_check' &&
                                data.measurements.assessment_state !== 'complete') {
                                // Use fixed-width spans for absolutely stable positioning
                                const paddedAngle = currentAngle.toString().padStart(3, '\u00A0');
                                // Get the best (max) angle for the current arm being tested
                                const bestAngle = Math.round(data.measurements.left_max || data.measurements.right_max || 0);
                                const paddedBest = bestAngle.toString().padStart(3, '\u00A0');
                                const angleHTML = '<div style="display: inline-flex; align-items: center; gap: 20px;">' +
                                    '<span style="color: #fbbf24; display: inline-block; width: 70px; text-align: right;">Current:</span>' +
                                    '<span style="font-weight: 700; color: #ffffff; display: inline-block; width: 55px; text-align: left; font-family: \'SF Mono\', Monaco, monospace;">' + paddedAngle + '°</span>' +
                                    '<span style="color: rgba(255,255,255,0.3); display: inline-block; width: 15px; text-align: center;">|</span>' +
                                    '<span style="color: #fbbf24; display: inline-block; width: 50px; text-align: right;">Best:</span>' +
                                    '<span style="font-weight: 700; color: #4ade80; display: inline-block; width: 55px; text-align: left; font-family: \'SF Mono\', Monaco, monospace;">' + paddedBest + '°</span>' +
                                    '</div>';
                                angleDisplayElement.innerHTML = angleHTML;
                            } else {
                                angleDisplayElement.innerHTML = '<div style="height: 22px;">\u00A0</div>'; // Maintain consistent height
                            }

                            // Show/hide arms down figure based on assessment state
                            const armsDownFigure = document.getElementById('armsDownFigure');
                            if (data.measurements.assessment_state === 'arms_at_sides_check') {
                                // Show the animated figure during arms-at-sides check
                                armsDownFigure.style.display = 'block';

                                // Start animation if not already running
                                if (!armsDownFigure.animationInterval) {
                                    // Animate between the two frames
                                    const frames = armsDownFigure.querySelectorAll('.arms-down-frame');
                                    let currentFrame = 0;

                                    armsDownFigure.animationInterval = setInterval(() => {
                                        // Hide current frame
                                        frames[currentFrame].style.opacity = '0';
                                        frames[currentFrame].classList.remove('active');

                                        // Show next frame
                                        currentFrame = (currentFrame + 1) % frames.length;
                                        frames[currentFrame].style.opacity = '1';
                                        frames[currentFrame].classList.add('active');
                                    }, 800); // Switch every 800ms
                                }
                            } else {
                                // Hide the figure when not in arms-at-sides check
                                armsDownFigure.style.display = 'none';

                                // Clear animation interval
                                if (armsDownFigure.animationInterval) {
                                    clearInterval(armsDownFigure.animationInterval);
                                    armsDownFigure.animationInterval = null;
                                }
                            }

                            // Handle hold countdown display
                            const holdCountdownElement = document.getElementById('holdCountdown');
                            const countdownNumberElement = document.getElementById('holdCountdownNumber');
                            const maxAngleDisplayElement = document.getElementById('maxAngleDisplay');

                            if (data.measurements.hold_time_remaining && data.measurements.hold_time_remaining > 0) {
                                // Show countdown timer
                                holdCountdownElement.style.display = 'block';

                                // Update countdown number
                                const secondsRemaining = Math.ceil(data.measurements.hold_time_remaining);
                                countdownNumberElement.textContent = secondsRemaining;

                                // Color changes based on time remaining
                                if (secondsRemaining <= 2) {
                                    countdownNumberElement.style.color = '#f59e0b'; // Orange for final seconds
                                } else if (secondsRemaining <= 3) {
                                    countdownNumberElement.style.color = '#fbbf24'; // Yellow-orange
                                } else {
                                    countdownNumberElement.style.color = '#4ade80'; // Green
                                }

                                // Show current max angle
                                const maxAngle = data.measurements.left_max || data.measurements.right_max || 0;
                                maxAngleDisplayElement.textContent = `Max: ${Math.round(maxAngle)}°`;

                                // Check if this is a new max (reset countdown)
                                if (data.measurements.new_max_reached) {
                                    // Flash effect for new max
                                    holdCountdownElement.style.animation = 'pulse 0.5s ease-out';
                                    setTimeout(() => {
                                        holdCountdownElement.style.animation = '';
                                    }, 500);

                                    // Play sound for new max
                                    const progbarSound = document.getElementById('progbarSound');
                                    progbarSound.currentTime = 0;
                                    progbarSound.play().catch(e => console.log('Audio play failed:', e));
                                }

                                // Check if hold is complete
                                if (data.measurements.hold_complete) {
                                    // Play completion sound
                                    const calibrationCompleteSound = document.getElementById('calibrationCompleteSound');
                                    calibrationCompleteSound.currentTime = 0;
                                    calibrationCompleteSound.play().catch(e => console.log('Audio play failed:', e));
                                }
                            } else {
                                // Hide countdown when not holding
                                holdCountdownElement.style.display = 'none';
                            }

                            // Switch progress bar side based on which arm is being tested
                            const romBar = document.getElementById('romProgressBar');
                            if (data.measurements.instruction.includes('LEFT')) {
                                // LEFT arm test - bar on right side (mirrored)
                                romBar.classList.remove('test-right');
                                romBar.classList.add('test-left');
                                // Reset angle tracking when starting left arm
                                if (data.measurements.assessment_state === 'test_left_arm' && !window.leftArmStarted) {
                                    window.previousAngle = 0;
                                    window.leftArmStarted = true;
                                    window.rightArmStarted = false;
                                }
                            } else if (data.measurements.instruction.includes('RIGHT')) {
                                // RIGHT arm test - bar on left side (mirrored)
                                romBar.classList.remove('test-left');
                                romBar.classList.add('test-right');
                                // Reset angle tracking when starting right arm
                                if (data.measurements.assessment_state === 'test_right_arm' && !window.rightArmStarted) {
                                    window.previousAngle = 0;
                                    window.rightArmStarted = true;
                                    window.leftArmStarted = false;
                                }
                            }
                        }

                        // Hide the floating instruction overlay - we're using bottom bar instead
                        if (data.measurements.instruction || data.measurements.assessment_state) {
                            console.log('📋 Instruction Update:', data.measurements);

                            // Hide the floating overlay
                            const instruction = document.getElementById('romInstruction');
                            if (instruction) {
                                instruction.style.display = 'none';
                            }

                            // Skip the old floating overlay code - we're using bottom bar now
                            // All instruction display is now handled in the bottom overlay bar
                        }

                        // Highlight reached markers
                        if (data.measurements.increment_reached) {
                            const markerId = `marker-${data.measurements.increment_reached}`;
                            const marker = document.getElementById(markerId);
                            if (marker && !marker.classList.contains('reached')) {
                                marker.classList.add('reached');

                                // Play sound for increments
                                if (data.measurements.increment_reached > lastIncrementPlayed) {
                                    lastIncrementPlayed = data.measurements.increment_reached;
                                    const progbarSound = document.getElementById('progbarSound');
                                    progbarSound.currentTime = 0;
                                    progbarSound.play().catch(e => console.log('Audio play failed:', e));
                                }
                            }
                        }

                        // Show report when assessment is complete
                        if (data.measurements.report) {
                            showAssessmentReport(data.measurements.report);
                        }

                        // Check if assessment is complete and show detailed report
                        if (data.measurements.complete && data.measurements.final_report) {
                            console.log('✅ Assessment complete! Stopping tracking and showing report.');

                            // Stop video processing
                            isProcessing = false;

                            // Hide video feed
                            document.getElementById('processedFeed').style.opacity = '0.3';

                            // Show comprehensive assessment report
                            showDetailedAssessmentReport(data.measurements.final_report);
                        }

                        // Update bottom overlay with angle info
                        const targetAngle = data.measurements.target_angle || 150;
                        const progress = data.measurements.progress_percentage || 0;
                        updateBottomOverlay(0, angle, progress, targetAngle);
                    } else {
                        // Regular exercise tracking (not PT assessment)
                        document.getElementById('romProgressBar').classList.remove('active');
                        document.getElementById('romInstruction').classList.remove('active');

                        // Update bottom overlay with real data
                        const angle = data.measurements.active_angle ||
                                     data.measurements.active_flexion || 0;
                        const reps = data.measurements.rep_count || 0;
                        const targetAngle = data.measurements.target_angle || 150;
                        const progress = data.measurements.progress_percentage || 0;

                        updateBottomOverlay(reps, angle, progress, targetAngle);
                    }
                }
            }
        });

        function updateBottomOverlay(reps, currentAngle, progress, targetAngle) {
            // Batch all DOM updates together to prevent reflows
            const exerciseNames = {
                'shoulder_abduction': 'SHOULDER ABDUCTION',
                'knee_flexion': 'KNEE FLEXION',
                'shoulder_flexion': 'SHOULDER FLEXION'
            };
            const currentExercise = sessionStorage.getItem('currentExercise') || 'shoulder_abduction';

            // Update exercise name only if changed
            const nameElement = document.getElementById('exerciseName');
            const expectedName = exerciseNames[currentExercise];
            if (nameElement && nameElement.textContent !== expectedName) {
                // Use innerHTML with fixed width span to prevent layout shift
                nameElement.innerHTML = `<span style="display: block; width: 100%; text-align: center;">${expectedName}</span>`;
            }
        }

        // Show detailed comprehensive assessment report
        function showDetailedAssessmentReport(report) {
            // Stop any ongoing video processing
            isProcessing = false;

            // Create a comprehensive report modal
            const existingModal = document.getElementById('detailedReportModal');
            if (existingModal) existingModal.remove();

            const modal = document.createElement('div');
            modal.id = 'detailedReportModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.95);
                backdrop-filter: blur(10px);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                animation: fadeIn 0.3s ease;
            `;

            const reportCard = document.createElement('div');
            reportCard.style.cssText = `
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                border-radius: 20px;
                padding: 40px;
                max-width: 800px;
                width: 90%;
                max-height: 85vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                border: 1px solid rgba(255,255,255,0.1);
                animation: slideUp 0.4s ease;
            `;

            // Generate timestamp
            const timestamp = new Date(report.timestamp).toLocaleString();

            reportCard.innerHTML = `
                <div style="text-align: center; margin-bottom: 30px;">
                    <h2 style="color: #ffffff; font-size: 32px; margin: 0; font-weight: 600;">
                        Shoulder Abduction Assessment Complete
                    </h2>
                    <div style="color: #94a3b8; font-size: 14px; margin-top: 8px;">${timestamp}</div>
                </div>

                <!-- Overall Status -->
                <div style="text-align: center; margin-bottom: 30px;">
                    <div style="display: inline-block; padding: 12px 24px; background: ${report.overall.color};
                                color: white; border-radius: 30px; font-size: 24px; font-weight: 600;">
                        ${report.overall.status}
                    </div>
                </div>

                <!-- Main Metrics Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                    <!-- Left Arm -->
                    <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #60a5fa; margin: 0 0 15px 0; font-size: 18px; text-align: center;">
                            LEFT ARM
                        </h3>
                        <div style="text-align: center; margin-bottom: 15px;">
                            <div style="font-size: 48px; font-weight: bold; color: #ffffff;">
                                ${report.left_arm.max_angle.toFixed(0)}°
                            </div>
                            <div style="color: ${report.left_arm.color}; font-size: 16px; margin-top: 5px;">
                                ${report.left_arm.icon} ${report.left_arm.category}
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #94a3b8; font-size: 14px;">
                            <span>Hold Duration:</span>
                            <span style="color: #ffffff;">${report.left_arm.hold_duration.toFixed(1)}s</span>
                        </div>
                        ${report.left_arm.target_achieved ?
                            '<div style="color: #10b981; text-align: center; margin-top: 10px;">✓ Target Achieved</div>' :
                            '<div style="color: #f97316; text-align: center; margin-top: 10px;">Target: 150°</div>'}
                    </div>

                    <!-- Right Arm -->
                    <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="color: #a78bfa; margin: 0 0 15px 0; font-size: 18px; text-align: center;">
                            RIGHT ARM
                        </h3>
                        <div style="text-align: center; margin-bottom: 15px;">
                            <div style="font-size: 48px; font-weight: bold; color: #ffffff;">
                                ${report.right_arm.max_angle.toFixed(0)}°
                            </div>
                            <div style="color: ${report.right_arm.color}; font-size: 16px; margin-top: 5px;">
                                ${report.right_arm.icon} ${report.right_arm.category}
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #94a3b8; font-size: 14px;">
                            <span>Hold Duration:</span>
                            <span style="color: #ffffff;">${report.right_arm.hold_duration.toFixed(1)}s</span>
                        </div>
                        ${report.right_arm.target_achieved ?
                            '<div style="color: #10b981; text-align: center; margin-top: 10px;">✓ Target Achieved</div>' :
                            '<div style="color: #f97316; text-align: center; margin-top: 10px;">Target: 150°</div>'}
                    </div>
                </div>

                <!-- Symmetry Analysis -->
                <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #fbbf24; margin: 0 0 15px 0; font-size: 18px;">Symmetry Analysis</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                        <div>
                            <div style="color: #94a3b8; font-size: 14px;">Difference</div>
                            <div style="color: #ffffff; font-size: 24px; font-weight: bold;">
                                ${report.symmetry.difference.toFixed(0)}°
                            </div>
                        </div>
                        <div>
                            <div style="color: #94a3b8; font-size: 14px;">Symmetry Score</div>
                            <div style="color: #ffffff; font-size: 24px; font-weight: bold;">
                                ${report.symmetry.percentage.toFixed(0)}%
                            </div>
                        </div>
                        <div>
                            <div style="color: #94a3b8; font-size: 14px;">Assessment</div>
                            <div style="color: ${report.symmetry.assessment === 'Symmetric' ? '#10b981' : '#f97316'};
                                        font-size: 20px; font-weight: bold;">
                                ${report.symmetry.assessment}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recommendations -->
                <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                    <h3 style="color: #10b981; margin: 0 0 15px 0; font-size: 18px;">Recommendations</h3>
                    <ul style="color: #e2e8f0; margin: 0; padding-left: 20px; line-height: 1.8;">
                        ${report.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                    </ul>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 15px; margin-top: 30px; justify-content: center;">
                    <button onclick="downloadAssessmentReport()" style="
                        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                        color: white;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.2s;
                    ">Export Report</button>
                    <button onclick="restartAssessment()" style="
                        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                        color: white;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: transform 0.2s;
                    ">Start New Assessment</button>
                    <button onclick="closeDetailedReport()" style="
                        background: rgba(255,255,255,0.1);
                        color: white;
                        border: 1px solid rgba(255,255,255,0.2);
                        padding: 12px 30px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">Close</button>
                </div>
            `;

            modal.appendChild(reportCard);
            document.body.appendChild(modal);

            // Store report data globally for export
            window.currentAssessmentReport = report;

            // Hide the bottom overlay when showing report
            document.getElementById('bottomOverlay').style.display = 'none';
            document.getElementById('romProgressBar').style.display = 'none';
        }

        // Close detailed report
        function closeDetailedReport() {
            const modal = document.getElementById('detailedReportModal');
            if (modal) {
                modal.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => modal.remove(), 300);
            }

            // Resume video if needed
            document.getElementById('bottomOverlay').style.display = 'flex';
        }

        // Restart assessment
        function restartAssessment() {
            closeDetailedReport();
            // Reset the assessment
            socket.emit('start_exercise', {
                session_id: sessionStorage.getItem('currentSessionId'),
                exercise_type: 'shoulder_abduction'
            });
            // Resume processing
            isProcessing = true;
            document.getElementById('processedFeed').style.opacity = '1';
            processFrames();
        }

        // Download assessment report as JSON
        function downloadAssessmentReport() {
            if (!window.currentAssessmentReport) return;

            const dataStr = JSON.stringify(window.currentAssessmentReport, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

            const exportFileDefaultName = `shoulder_assessment_${new Date().toISOString().split('T')[0]}.json`;

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        // Show assessment report (keep existing function for backward compatibility)
        function showAssessmentReport(report) {
            const reportModal = document.getElementById('assessmentReport');
            const metricsContainer = document.getElementById('reportMetrics');
            const ratingContainer = document.getElementById('reportRating');

            // Clear previous content
            metricsContainer.innerHTML = '';

            // Check if this is a dual-arm report (shoulder abduction)
            if (report.left_arm && report.right_arm) {
                // Display both arms side by side
                metricsContainer.style.display = 'grid';
                metricsContainer.style.gridTemplateColumns = '1fr 1fr';
                metricsContainer.style.gap = '30px';

                // LEFT ARM SECTION
                const leftDiv = document.createElement('div');
                leftDiv.innerHTML = `
                    <h3 style="color: #4ade80; margin: 0 0 15px 0; text-align: center;">LEFT ARM</h3>
                    <div style="background: rgba(74, 222, 128, 0.1); padding: 15px; border-radius: 10px;">
                        <div style="margin-bottom: 12px;">
                            <div style="color: #888; font-size: 12px;">Max Angle</div>
                            <div style="color: white; font-size: 24px; font-weight: bold;">${report.left_arm.max_angle}°</div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="color: #888; font-size: 12px;">Range of Motion</div>
                            <div style="color: white; font-size: 18px;">${report.left_arm.range_of_motion}°</div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="color: #888; font-size: 12px;">Test Duration</div>
                            <div style="color: white; font-size: 16px;">${report.left_arm.test_duration}s</div>
                        </div>
                        <div>
                            <div style="color: #888; font-size: 12px;">Increments Reached</div>
                            <div style="color: white; font-size: 14px;">${report.left_arm.increments_achieved.map(v => `${v}°`).join(', ') || 'None'}</div>
                        </div>
                    </div>
                `;

                // RIGHT ARM SECTION
                const rightDiv = document.createElement('div');
                rightDiv.innerHTML = `
                    <h3 style="color: #60a5fa; margin: 0 0 15px 0; text-align: center;">RIGHT ARM</h3>
                    <div style="background: rgba(96, 165, 250, 0.1); padding: 15px; border-radius: 10px;">
                        <div style="margin-bottom: 12px;">
                            <div style="color: #888; font-size: 12px;">Max Angle</div>
                            <div style="color: white; font-size: 24px; font-weight: bold;">${report.right_arm.max_angle}°</div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="color: #888; font-size: 12px;">Range of Motion</div>
                            <div style="color: white; font-size: 18px;">${report.right_arm.range_of_motion}°</div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="color: #888; font-size: 12px;">Test Duration</div>
                            <div style="color: white; font-size: 16px;">${report.right_arm.test_duration}s</div>
                        </div>
                        <div>
                            <div style="color: #888; font-size: 12px;">Increments Reached</div>
                            <div style="color: white; font-size: 14px;">${report.right_arm.increments_achieved.map(v => `${v}°`).join(', ') || 'None'}</div>
                        </div>
                    </div>
                `;

                metricsContainer.appendChild(leftDiv);
                metricsContainer.appendChild(rightDiv);

                // Performance ratings and comparison
                ratingContainer.innerHTML = `
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; margin-top: 20px;">
                        <h3 style="margin: 0 0 15px 0; color: #D2A10C; text-align: center;">Performance Summary</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div style="text-align: center;">
                                <div style="color: #4ade80; font-size: 14px; margin-bottom: 5px;">Left Arm</div>
                                <div style="color: white; font-size: 14px; line-height: 1.4;">${report.left_arm.performance_rating}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #60a5fa; font-size: 14px; margin-bottom: 5px;">Right Arm</div>
                                <div style="color: white; font-size: 14px; line-height: 1.4;">${report.right_arm.performance_rating}</div>
                            </div>
                        </div>
                        <div style="text-align: center; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="color: #888; font-size: 12px; margin-bottom: 5px;">Arm Balance</div>
                            <div style="color: ${report.comparison === 'Balanced' ? '#4ade80' : '#f59e0b'}; font-size: 20px; font-weight: bold;">
                                ${report.comparison}
                                ${report.comparison === 'Asymmetric' ? ' ⚠️' : ' ✓'}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Original single report display (for other exercises)
                const metrics = [
                    { label: 'Max Angle', value: `${report.max_angle}°` },
                    { label: 'Range of Motion', value: `${report.range_of_motion}°` },
                    { label: 'Average Angle', value: `${report.average_angle}°` },
                    { label: 'Test Duration', value: `${report.test_duration}s` }
                ];

                metrics.forEach(metric => {
                    const metricDiv = document.createElement('div');
                    metricDiv.className = 'report-metric';
                    metricDiv.innerHTML = `
                        <div class="report-metric-label">${metric.label}</div>
                        <div class="report-metric-value">${metric.value}</div>
                    `;
                    metricsContainer.appendChild(metricDiv);
                });

                // Add increments achieved
                if (report.increments_achieved && report.increments_achieved.length > 0) {
                    const incrementsDiv = document.createElement('div');
                    incrementsDiv.className = 'report-metric';
                    incrementsDiv.style.gridColumn = 'span 2';
                    incrementsDiv.innerHTML = `
                        <div class="report-metric-label">Increments Achieved</div>
                        <div class="report-metric-value">${report.increments_achieved.join('°, ')}°</div>
                    `;
                    metricsContainer.appendChild(incrementsDiv);
                }

                // Add performance rating
                ratingContainer.innerHTML = `
                    <h3 style="margin: 0 0 10px 0; color: #D2A10C;">Performance Rating</h3>
                    <p style="margin: 0; font-size: 18px;">${report.performance_rating}</p>
                `;
            }

            // Show modal
            reportModal.style.display = 'flex';
        }

        // Close assessment report
        function closeReport() {
            document.getElementById('assessmentReport').style.display = 'none';
            // Reset assessment for next test
            lastIncrementPlayed = 0;

            // Reset all ROM markers
            const markers = document.querySelectorAll('.rom-marker');
            markers.forEach(marker => {
                marker.classList.remove('reached');
            });

            // Reset angle display with proper formatting
            document.getElementById('currentAngleDisplay').innerHTML = '<span style="display: inline-block; min-width: 4ch; text-align: right;">  0°</span>';
            document.getElementById('romBarFill').style.height = '0%';
        }

        // Reset ROM markers when starting new assessment
        function resetROMDisplay() {
            const markers = document.querySelectorAll('.rom-marker');
            markers.forEach(marker => {
                marker.classList.remove('reached');
            });
            lastIncrementPlayed = 0;
            window.previousAngle = 0; // Reset angle tracking for sound effects
            window.leftArmStarted = false; // Reset arm tracking flags
            window.rightArmStarted = false;
            document.getElementById('currentAngleDisplay').innerHTML = '<span style="display: inline-block; min-width: 4ch; text-align: right;">  0°</span>';
            document.getElementById('romBarFill').style.height = '0%';
        }

        // Add keyboard shortcut to stop
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                isProcessing = false;
                frameCount = 0;
                location.reload();
            }
        });
    </script>
</body>
</html>